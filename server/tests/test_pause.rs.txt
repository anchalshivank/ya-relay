use std::rc::Rc;
use std::sync::atomic::Ordering::SeqCst;
use std::sync::atomic::{AtomicBool};
use std::time::Duration;

use anyhow::Context;
use futures::{SinkExt, StreamExt};
use tokio::sync::mpsc;

use ya_relay_client::{Client, ClientBuilder};
use ya_relay_server::testing::server::{init_test_server, ServerWrapper};
use ya_relay_server::server::FORWARDER_RESUME_INTERVAL;

async fn start_clients(wrapper: &ServerWrapper, count: u32) -> Vec<Client> {
    let mut clients = vec![];
    for _ in 0..count {
        clients.push(
            ClientBuilder::from_url(wrapper.server.inner.url.clone())
                .connect()
                .build()
                .await
                .unwrap(),
        )
    }
    clients
}

fn spawn_receive<T: std::fmt::Debug + 'static>(
    label: &'static str,
    received: Rc<AtomicBool>,
    rx: mpsc::UnboundedReceiver<T>,
) {
    tokio::task::spawn_local({
        let received = received.clone();
        async move {
            rx.for_each(|item| {
                let received = received.clone();
                async move {
                    println!("{} received {:?}", label, item);
                    received.clone().store(true, SeqCst)
                }
            })
            .await;
        }
    });
}

#[serial_test::serial]
async fn test_client_pause() -> anyhow::Result<()> {

    // setup 2 clients and server
    let wrapper = init_test_server().await.unwrap();
    let clients = start_clients(&wrapper, 2).await;
    let client_b_rx = clients[1].forward_receiver().await.context("no forward receiver")?;
    let client_b_node_id = clients[1].node_id().await;
    let client_a_session = clients[0].server_session().await?;
    let node_b = client_a_session.find_node(client_b_node_id).await?;
    let client_b_received = Rc::new(AtomicBool::new(false));
    spawn_receive(">> 1", client_b_received.clone(), client_b_rx);

    println!("before: {:?}", wrapper.server.state.read().await.nodes.get_by_session(client_a_session.id().await?).unwrap().last_seen);
    // client a sends forward message to client b
    let mut tx1 = client_a_session.forward_unreliable(node_b.slot).await?;
    tx1.send(vec![1u8]).await?;
    tokio::time::delay_for(Duration::from_millis(10)).await;
    assert!(client_b_received.load(SeqCst));
    client_b_received.store(false, SeqCst);
    // TODO: check if server received?
    println!("after: {:?}", wrapper.server.state.read().await.nodes.get_by_session(client_a_session.id().await?).unwrap().last_seen);

    // server sends PauseForwarding

    // client a sends forwarded message to client b

    // assert server did not receive
    // assert client b did not receive

    Ok(())
}
//
// #[serial_test::serial]
// async fn test_pause_at_limit() -> anyhow::Result<()> {
//
//     std::env::set_var("FORWARDER_RATE_LIMIT", "2");
//     // start 2 clients and server
//     let wrapper = init_test_server().await.unwrap();
//     let clients = start_clients(&wrapper, 2).await;
//
//     let client_b_rx = clients[1].forward_receiver().await.context("no forward receiver")?;
//
//     // connect the bunch
//     let client_b_node_id = clients[1].node_id().await;
//     let client_a_session = clients[0].server_session().await?;
//
//     let node_b = client_a_session.find_node(client_b_node_id).await?;
//     let client_b_received = Rc::new(AtomicBool::new(false));
//     spawn_receive(">> 1", client_b_received.clone(), client_b_rx);
//
//     // client_A sends simple forward messages to client_B
//     let mut tx1 = client_a_session.forward_unreliable(node_b.slot).await?;
//     tx1.send(vec![1u8]).await?;
//     tokio::time::delay_for(Duration::from_millis(10)).await;
//     assert!(client_b_received.load(SeqCst));
//     client_b_received.store(false, SeqCst);
//
//     tx1.send(vec![1u8]).await?;
//     tokio::time::delay_for(Duration::from_millis(10)).await;
//     assert!(client_b_received.load(SeqCst));
//     client_b_received.store(false, SeqCst);
//
//     // server sends pause to client_A
//
//     // assert client_A stops sending messages
//     tx1.send(vec![1u8]).await?;
//     tokio::time::delay_for(Duration::from_millis(10)).await;
//     assert!(!client_b_received.load(SeqCst));
//
//     // assert client_A starts sending after default timeout
//     tokio::time::delay_for(Duration::from_secs(*FORWARDER_RESUME_INTERVAL)).await;
//     tx1.send(vec![1u8]).await?;
//     tokio::time::delay_for(Duration::from_millis(10)).await;
//     assert!(client_b_received.load(SeqCst));
//
//     Ok(())
// }
